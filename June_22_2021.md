
<img src='./images/class_logo.png' width=500px align='right' style='padding-left:30px'>

**Week 3**<br>
**ATMOS 5340: Environmental Programming and Statistics**<br>
**John Horel**<br>
*Building on content developed by Brian Blaylock and Derek Mallia*<br>
<br>

> # Announcement: 
> **

> # Today's Objective
> Python flow control and conditional statements
> Input/output operations
<br><br>

#  Python Loops and Conditional Statements
## Chapter 5 from the Alex DeCaria textbook: 'Flow Control'

Loops are often used to iterate through a sequeunce, list, dictionary, tuple, or an array. Conditional statements, often using booleans, can be employed to determine when a specific code block should be executed (or skipped).
- `For` and `while` loops are primarily used to iterate over an *idented* block of code 
- Conditional statements, or `if` statements are often used to determine whether a block of code should be executed or not


**Before starting:** Make sure that you open up a Jupyter notebook session using OnDemand so you can interactively follow along with today's lecture! If you have forgotten how to do this, refer to the previous lecture and class notes.

<br><br>
---
---

# Conditional statements

Conditional statements are used to execute a specific block of code, if specific conditions are met. Conditional statements almost always start with an *if construct*.

    if condition is met:
        execute the following lines of code
    
    #end of if statement block

Generally conditional statements are checked using mathematical logical conditions.

Recall: 

>- Equals: a == b
>- Not Equals: a != b
>- Less than: a < b
>- Less than or equal to: a <= b
>- Greater than: a > b
>- Greater than or equal to: a >= b

If statements can also be embedded with Python loops, which we will go over later in this lecture...

For cases where there are multiple conditions, an *if else* `elif` syntax can be added to the first condition:

    if condition is met:
        execute the following lines of code
    if else do we meet this condition?:
        execute this block
    if else do we meet this condition?:
        execute this block
    
    #end of if statement block
    
**Note** There are no limits to how many elif statements can be used!

Finally, an `else` construct can be used at the end of if conditional statement to execute lines of code for cases where none of the prior conditions are met. For example

    if condition is met:
        execute the following lines of code
    else:
        execute this line of code instead
    
    #end of if statement block

<br><br>

Lets look at some lines of *actual* python code that utilizes conditional statements like the ones we went over above! 

    temp = 30
    
    if temp <= 32:
        print('The temperature is at or below freezing')
        
>> What happens here?

    temp = 50
    
    if temp <= 32:
        print('The temperature is at or below freezing')
        
 
        
<br><br>
Since our temperature variable 'temp' does not meet the criteria of our `if` statement, it skips the lines of code within our `if` statement block.

‚ùó‚ùó‚ùó‚ùó Do not forget to add a colon `:` after each `if`, `elif`, and `else` construct


Here is an example of an `if` statement with a else construct:

    temp = 30
    
    if temp <= 32:
        print('The temperature is at or below freezing')
    else:
        print('The temperature is above freezing!')
        
    >> The temperature is at or below freezing

<br><br>

And here is an example of an `if` statement with an if else construct:

    #Thunderstorm probability
    tstorm = 30
    
    if 20 >= tstorm:
        print('Little to no chance of thunderstorms today')
    elif 20 < tstorm <= 40:
        print('Slight chance of thunderstorms today')
    elif 40 < tstorm <= 60:
        print('Chance of thunderstorms today')
    elif 60 < tstorm:
        print('Thunderstorms are likely today')
        
>> What do you think the result will be here?!

<br><br>
---
---

# Loops

There are two types of loops used the most in Python: `for` and `while` loops.

`for` loops always require an iterable object and has a similar syntax as a conditional statement. 

    for var in iterable object:
        do stuff in
        this line for 
        each iteration 
        that we are 
        looping through
        
    #end of for loop
        

In this syntax *iterable object* represents an iterable object that is being loop through, while  *var* hold the value of the 
current value of the iterable object. The python code block within the `for` loop will be performed for each iteration being performed. 
The number of iterations will be equal to the number of elements within the iterable object. 

Lets look at an example:

    temp = [36,38,40,44,48,53,60,62,64,65,65,63,60,55,50] 

    for T in temp:
        print(T)
        
    >> 36
    >> 38
    >> 40
    >> 44
    .......
    >> 50
        
When we run this block of code, Python iterate through each element within our object 'temp'. In this loop we have told Python to run the print statement for each iterable element (T) in temperature. 

<br><br>
You can also can also use a prefined range object as a iterable object. 

    for c in range(0,10):
       print('Counting.... '+str(c))
    
    >> Counting.... 0
    >> Counting.... 1
    >> Counting.... 2
    ....
    >> Counting.... 10

<br><br>
Sometimes, it is useful to keep track of which iteration we are working on when looping through a variable using the `enumerate` command. Personally, I use this in most of my Python code, especially when I am trouble shooting bugs! For example, there may be a specific iteration where my code breaks, so its always useful to know where this happens!


    temperature = [36,38,40,44,48,53,60,62,64,65,65,63,60,55,50] 
    
    for t, temp in enumerate(temperature):
        print(t,temp)
        
    >> 0 36
    >> 1 38
    >> 2 40
    ...
    >> 14 50
    

<br><br>
---
---

`while` loops are the other looping construct used within Python. This loop runs for as a long as a specific criteria is being met.

    while condition is being met:
        execute this code block
        
    #end while loop
    
For example:
 
    a = 0
    while a < 5:
        print(a)
        a = a + 1
        
    >> 0
    >> 1 
    >> 2
    >> 3
    >> 4
 
This will loop through the above code block until the condition a < 5 is met.

‚ùó‚ùó Be careful when working with `while` loops as it is possible to accidently create a loop that runs infinitely, that is, a code that "hangs" and has to be terminated manually. 

<br><br>
---
---

# Other flow control constructs

Sometimes we may want to control a loop if a specific criteria is met within a loop. This often requires combining conditional and looping constructs.

For example, we may want to prematurely end an iteration within a loop if a spefific criteria is met:

    temperature = [60,61,61,58,55,50,44,37,30,28,26,25]
    
    for t,temp in enumerate(temperature):
        if 50 > temp > 30:
            continue
        print(t,temp)
 
    >> 0 60
    >> 1 61
    >> 2 61
    >> 3 58
    >> 4 55
    >> 5 50
    >> 8 30
    >> 9 28
    >> 10 26
    >> 11 25
 
Here, we loop through each element in temperature. For cases where the temperature is less than 50 but greater than 30, the `if` statement condition is triggered. For elements where the `conditional` is met, the `continue` statement within our conditional statement is executed, which tells Python to ignore the lines after the `continue` statement for the iteration we are working on. 


The `break` loop control statement can be used to  prematurely exit a loop:


    temperature = [60,61,61,58,55,50,44,37,30,28,26,25]
    
    for temp in temperature:
        if 50 > temp > 30:
            break
        print(temp)
    print('Broke out of loop')
 
    >> 60
    >> 61
    >> 61
    >> 58
    >> 55
    >> 50
    >> Broke out of loop

 
The `break` command can be used in conjunction with `for` and `while` loops

    
<br><br>
---
---
    

> # Want more practice on flow control!?<br>
> Check out the following webpages:<br>
> https://www.tutorialspoint.com/python3/python_decision_making.htm<br>
> https://www.tutorialspoint.com/python3/python_loops.htm<br>
> https://www.w3schools.com/python/python_for_loops.asp<br>
> https://www.w3schools.com/python/python_conditions.asp<br>

---
---
#  Python File I/O
## Chapter 6 from the Alex DeCaria textbook: 'File I/O'

Environmental science files are data intensive. Sometimes the data are in non-compressed file formats such as text or csv-formatted files. However, sometimes data are  stored in compressed file formats such as Hierarchical Data Format version 5 (HDF5) or Network Common Data Form (netCDF). We will only consider uncompressed text/csv formats here.

Topics:
- Reading and writing data in a text-like format

**Before starting:** Make sure that you open up a Jupyter Lab session using OnDemand so you can interactively follow along with today's lecture! 

<br><br>
---
---

# Opening and closing files

We're going to skip over this basic way of opening/closing files and go right to using an easy way to read an entire file

**Opening files:** Files can be simply opened using Python's `open()` function, which uses the following syntax:

    my_file = 'file.txt'
    
    f = open(my_file, <mode here>)
    

The arguments for our function include the file name, which we want to read in (this should be a 'string'), and an argument for mode that refers to how we want to open up our file. The variable `f` will contain a reference to the resulting file object. Listed below are the available modes for accessing a file:

>- `r`: Text file is opened as read only
>- `w`: Text file is open as write only. Any new output will overwrite the exist file.
>- `r+` or `w+`: Text file is opened for reading and writing. Any new output will overwrite the exist file.
>- `a`: Text file is opened for writing in an appended mode. Any new changes to the file will be appended at the end.
>- `b`: This tell Python to open the file as a binary file. For exampe, `rb` indicates a read-only binary file, and `rb+` would indicate a read and write enabled binary. This is usually needed when opening csv files with the csv module. More on this later...

**Closing files:** A file will be closed using the `close()` method. This can be accomplished by *appending* the method to the file object.

    f.close()
    
<br><br>
---
---

# Reading in text from files

Similar to before, we will use the `open` statement to access data within a text file. First, open up a CHPC OnDemand linux terminal, and
copy the following file into your Atmos 5340 directory. Feel free to make a subdirectory for Module_6!

    mkdir Module_6
    cp /uufs/chpc.utah.edu/common/home/u0703457/public_html/dereks_homepage/Atmos_5340/class_files/module6_datafile1.txt Module_6/

‚ö†Ô∏è‚ö†Ô∏è Even though we have not used linux in a few weeks, what we learned earlier in this semester will become increasingly helpful, especially as we get closer to the end of the semester. So keep those linux skills sharp üî™üî™

Lets open up the `module6_datafile1.txt` text file that we copied over into our working directory....

    f = open('module6_datafile1.txt','r')
    
now, lets use Python's `readline()` method to output the lines within our text file... 

    f.readline()
    >> "Today's weather forecast for Salt Lake City is:\n"
    
    f.readline()
    >> 'Sunny, with a high near 91. \n'
    
    f.readline()
    'Southwest wind around 10 mph \n'
    
    f.readline()
    'Winds becoming west northwest later in the day.'
    

‚ö†Ô∏è‚ö†Ô∏è Note that parts of section 6.3 from the DeCaria textbook is slightly outdated, as the `next` method became depreciated in Python versions newer than 3.3. `readline()` has replaced `next`. ‚ö†Ô∏è‚ö†Ô∏è
<br> <br>

We can also employ what we learned from the last lecture, and use a Python's `for` loop construct to read in each line of our text file!

    f = open("module6_datafile1.txt", "r")
    for x in f:
        print(x)

    f.close()      #Lets make sure sure that we close our file!
    
    
    >> Today's weather forecast for Salt Lake City is:
    >> Sunny, with a high near 91. 
    >> Southwest wind around 10 mph 
    >> Winds becoming west northwest later in the day.

<br>
If you want, you can also read in the entire file as a list...

    with open("module6_datafile1.txt", "r") as f:
        data = f.readlines()
    
    print(data)

    >> ["Today's weather forecast for Salt Lake City is:\n", 'Sunny, with a high near 91. \n', 'Southwest wind around 10 mph \n', 'Winds becoming west northwest later in the day.']
    
   
<br><br>
---
---

# Writing text to a file

File objects also have the `write` method, which write a single string to a text file. Lets make a copy of our `module6_datafile1.txt` file in linux and call it `module6_datafile2.txt`. ‚ö†Ô∏è‚ö†Ô∏è Do you remember how to do this? ‚ö†Ô∏è‚ö†Ô∏è 

Next, lets append the following strings to our text file. 

    with open("module6_datafile2.txt", "a") as f:
        f.write('Tomorrow: A slight chance of showers before 11am.\n')
        f.write('Then a slight chance of showers and thunderstorms after noon.\n')
        f.write('Mostly sunny, with a high near 81. Calm wind.\n')
        f.write('Chance of precipitation is 20%.\n')
        
Lets go back to our linux terminal and examine our file. How do we do this again? Do we notice anything different about our `module6_datafile2.txt` file?
    

<br><br>
---
---

# Reading and writing Delimited files

Using Python's csv module, we can read in data seperated by commas, colons, white spaces, or some other delimiter. Spread sheet programs like Microsoft excel often use csv files, so this is a pretty common format to see data in! Luckly for us, Python has an easy way of working with csv files.

Before we try this out, copy the following file to your working directory:

    /uufs/chpc.utah.edu/common/home/u0703457/public_html/dereks_homepage/Atmos_5340/class_files/module6_datafile3.txt

<br>
Next, lets go back to our Jupyter Notebook session and activate Python's csv module and open our csv file:

    import csv 
    
    f = open("module6_datafile3.txt","r")
    
‚ö†Ô∏è‚ö†Ô∏è Sometimes, we use `rb` for the mode argument, since openig a file with the csv module can yield weird results when a file it **NOT** opened in binary mode. I am feeling particurly risky today, so for now we will just open our simple csv file using the `r` mode. 

    r = csv.reader(f,delimiter = ',')
    
Here, we assume that our values in our text file are seperated with the `,` delimiter. We can confirm this by just look at the contents of our file in our linux terminal. You may need to confirm this each time when working with different files, as different people/institutions will format their csv files in different ways. Anyways, since our values are indeed seperated with a `,`, we set our delimiter argument as `,`.

<br>
As a next step, lets open our csv file, read in each line, and seperate our values based on the `,` delimiter, skip our header, and save each line to our data variable called `data`:

    import csv 
    with open("module6_datafile3.txt","rb"):
        r = csv.reader(f,delimiter = ',')
        for i, data in enumerate(r):
            if i == 0:
                pass
            else:
                print(data)
                
     >> ['Alex', ' Layton', ' 51', ' 72', ' 195']
     >> ['Francis', ' Ogden', ' 34', ' 68', ' 177']
     >> ['Megan', ' Las Vegas', ' 23', ' 65', ' 120']
     >> ['Lois', ' St. George', ' 56', ' 60', ' 130']
     >> ['Derek', ' North Salt Lake', ' 33', ' 67', ' 173']
     
     
     
                
This simple code is a nice example of the many concepts that we've learned in this class so far!

<br>

<br><br>
---
---

# os.Path Module
This is another handy module built in into Python. I often use this when I need to loop through multiple data files, often located in a single directory. This is also used to check for existing files and directories, or listing files/directories. To import the `os.path` module do the following:

    import os.path as os 
    
Since os.path is kind of a long name, lets shorthand this is `os`. The above command tells Python to import the os.path module and to shorthand all function related to this module as `os`.

Lets work with our working directory, which should look something like `blah/blah/more_blah/Atmos_5340/module_6`

We can shorthand this as `.` in linux. So lets set a variable named path as our current working directory:

    path = '.'

Now, lets return the absolute path of our working directory....

    os.abspath(path)
    
We'll go over more examples of how to skillfully use the os.Path module in future lectures!


<br><br>
---
---

# Remote file access

In the age of cloud computing, sometimes the data you are accessing are either in the cloud, on a remote server. Fortunately, Python is equiped with an easy way for accessing these types of files.

First, important the `urllib` module:

    import urllib.request
    
‚ö†Ô∏è‚ö†Ô∏è Since we are using Python 3, there is no urllib module anymore. The urllib library has been split into several modules. `urllib` is now equivalent to `urlretrieve`, so disregard the `import urllib` command in the DeCaria text. `urlretrieve` behaves exactly the same way as it did in Python version 2.x, so it'll work just fine here.

Lets grab some data now...

    url = "http://home.chpc.utah.edu/~u0703457/dereks_homepage/Atmos_5340/class_files/samplesounding.txt"

    filename, headers = urllib.request.urlretrieve(url,'MyCopy.txt')

    
This will save the file to our working directory.

    f = open("MyCopy.txt", "r")
    for x in f:
        print(x)

    f.close()      #Lets make sure sure that we close our file!
    
With the print command, you will see the contents of this file, albeit, not exactly in this most structured format. Python's Pandas module
will allow us to better organize and sort data, which we will review in 2 weeks...


<br><br>
---
---

# Opening Python objects

An NPY file is a NumPy array file created by the Python software package with the NumPy library installed. It contains an array saved in the NumPy (NPY) file format. NPY files store all the information required to reconstruct an array on any computer, which includes dtype and shape information. In this class, we will be occasionally saving NumPy arrays and reading them as NumPy files:

Lets create an array object:

    import numpy as np
    from numpy import random

    xrand = random.randint(100, size=(10, 10))


You can save this as in NumPy file by running the following line:

    np.save('random_array.npy',xrand)

You can load an array in an NPY file by using np.load('filename.npy').

    my_array = np.load('random_array.npy')


<br><br>
---
---

# Grib files

Grib files is a compressed file format often used in the atmospheric sciences to archieve historical and forecast weather data such as the GFS, usually in a gridded format. It is standardized by the World Meteorological Organization's Commission for Basic Systems. The variables within gribs files are usually self describing. One limitation is that each record is independent. 

    import pygrib
    import numpy as np
    
    path='/uufs/chpc.utah.edu/common/home/u0703457/public_html/dereks_homepage/Atmos_5340/class_files/GFS'
    gFile = '/gfs.t00z.pgrb2.1p00.f000'

    #open file using pygrib
    grbs = pygrib.open(path+gFile)
    
    #what is in the file?
    for g in grbs:
        print (g.typeOfLevel, g.level, g.name, g.shortName,g.validDate, g.analDate, g.forecastTime)

    >> hybrid 1 Cloud mixing ratio clwmr 2020-08-12 00:00:00 2020-08-12 00:00:00 0
    >> hybrid 1 Ice water mixing ratio icmr 2020-08-12 00:00:00 2020-08-12 00:00:00 0
    >> hybrid 1 Rain mixing ratio rwmr 2020-08-12 00:00:00 2020-08-12 00:00:00 0
    >> hybrid 1 Snow mixing ratio snmr 2020-08-12 00:00:00 2020-08-12 00:00:00 0

<br><br>
Lets poke around and look at one of the variables that we read in...

    #Lets read in a variable
    h = grbs.select(shortName='gh',level=500)
    
    #Extract all the values
    h5_all = h[0].values

    #what are the dimensions? note lat first, lon second
    print(np.shape(h5_all))

    # Get the lat/lon grids from the grib2 file using the .latlons() method
    lats_all, lons_all = h[0].latlons()
    

More information about grib files and the pygrib module can be found here: https://jswhit.github.io/pygrib/docs/


     
    
<br><br><br>

> # Want more practice!?<br>
> Check out the following webpages:<br>
> http://www.johnny-lin.com/pyintro/ed01/free_pdfs/ch05.pdf<br>
> https://www.tutorialspoint.com/python3/python_files_io.htm<br>
> https://www.w3schools.com/python/python_file_handling.asp<br>
> https://www.w3schools.com/python/python_file_write.asp<br>
> https://www.w3schools.com/python/python_file_remove.asp<br>




